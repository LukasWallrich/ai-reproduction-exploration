---
title: "Reproduction Report: Munzert & Bauer (2013)"
subtitle: "Political Depolarization in German Public Opinion, 1980–2010"
author: "AI Reproduction"
date: today
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: true
    code-summary: "Show code"
    embed-resources: true
keep-md: true
execute:
  warning: false
  message: false
  cache: false
---

::: {.callout-warning appearance="simple"}
## Exploratory AI Capability Study

This report was generated autonomously by an AI agent as part of an exploratory study into the capabilities of agentic AI for computational reproduction. **It is not an independent assessment of the original paper.** The AI agent may have made errors in data processing, analytical decisions, or interpretation. Any discrepancies reported here may reflect limitations of the AI reproduction process rather than issues with the original research.
:::

```{r setup}
#| label: setup
#| include: false

library(tidyverse)
library(haven)
library(lmerTest)  # Provides Satterthwaite p-values for lmer models
library(knitr)
library(kableExtra)

set.seed(12345)

# Helper function for deviation classification
classify_deviation <- function(paper_value, reproduced_value, paper_decimals = NULL) {
  abs_dev <- abs(reproduced_value - paper_value)

  if (is.null(paper_decimals)) {
    pv_str <- sub("0+$", "", format(paper_value, scientific = FALSE, nsmall = 10))
    if (grepl("\\.", pv_str)) {
      paper_decimals <- nchar(sub(".*\\.", "", pv_str))
    } else {
      paper_decimals <- 0
    }
  }

  rounds_same <- round(reproduced_value, paper_decimals) == round(paper_value, paper_decimals)

  # Always compute relative deviation (NA only if paper_value is exactly 0)
  rel_dev <- if (paper_value == 0) NA_real_ else abs_dev / abs(paper_value) * 100

  if (abs(paper_value) < 0.2) {
    # Near-zero rule: use absolute threshold for classification
    category <- case_when(
      rounds_same ~ "Exact",
      abs_dev <= 0.01 ~ "Minor deviation",
      TRUE ~ "Substantive deviation"
    )
  } else {
    category <- case_when(
      rounds_same ~ "Exact",
      rel_dev <= 5 ~ "Minor deviation",
      TRUE ~ "Substantive deviation"
    )
  }
  tibble(
    abs_deviation = abs_dev,
    rel_deviation_pct = rel_dev,
    category = category
  )
}

style_deviation <- function(category) {
  colors <- c(
    "Exact" = "#d4edda",
    "Minor deviation" = "#fff3cd",
    "Substantive deviation" = "#f8d7da",
    "Conclusion change" = "#f5c6cb"
  )
  bg <- colors[category]
  if (is.na(bg)) bg <- "#ffffff"
  paste0("background-color: ", bg, ";")
}
```

::: {.callout-note appearance="minimal"}
## Abstract

**Paper**: Munzert, S. & Bauer, P.C. (2013). Political Depolarization in German Public Opinion, 1980–2010. *Political Science Research and Methods*, 1(1), 67–89. doi:10.1017/psrm.2013.7

**Data**: ALLBUS Cumulation 1980–2010 (GESIS ZA4576), N = 54,243 individual respondents; 806 issue-pair-year observations across 252 attitude scale pairs.

**Verdict**: QUALITATIVELY REPRODUCED

All five abstract claims are confirmed in direction. The data structure (806 pair-year observations, 252 unique pairs) matches exactly. Fixed effects from the multilevel models show minor deviations (e.g., overall time trend -0.03 vs. -0.04 per decade), possibly due to dataset version differences (ZA4576 vs. ZA4572). All qualitative conclusions hold: (1) overall depolarization, (2) dimension-specific patterns, (3) stronger depolarization among the highly educated and politically interested, and (4) increasing polarization on gender issues. Note that the paper reports coefficients with SEs but no significance tests; reproduced significance is computed using Satterthwaite p-values from lmerTest.
:::

## Open Materials

| Material | Available | Location |
|----------|-----------|----------|
| Supplementary materials | Yes | Journal website (appendix with additional figures) |
| Replication code | No | — |
| Replication data (processed) | No | — |
| Raw data | Yes | GESIS Data Archive (registration required) |

The paper references supplementary materials at the journal website (http://dx.doi.org/10.1017/psrm.2013.7). No replication code or processed data were available. Raw ALLBUS data were obtained from the GESIS archive. Replication materials were not consulted during this reproduction.

---

## Paper Overview

### Research Question
How has public opinion polarization (POP) in Germany developed over the last three decades (1980–2010)? POP is conceptualized as alignment of attitudes across multiple issue dimensions.

### Key Methods
- **Data**: ALLBUS (German General Social Survey), 17 waves from 1980 to 2010
- **Measure**: Pairwise Pearson correlations between 24 attitude items, classified into four dimensions (gender, moral, distribution, immigration)
- **Models**: Multilevel models (varying intercept, varying slope) with correlation as DV, time (decades, centered at 1994) as predictor, and attitude scale pairs as grouping variable
- **Sub-group analysis**: Separate models for sub-populations defined by gender, education, political interest, income, religious denomination, and East/West Germany

### Claims from the Abstract

1. **POP as alignment**: Public opinion polarization is conceptualized and measured as alignment of attitudes across multiple issue dimensions using pairwise correlations.
2. **Overall decrease**: Public opinion polarization has decreased over the last three decades in Germany.
3. **Dimension-specific patterns**: Multilevel models reveal general and dimension-specific levels and trends in attitude alignment.
4. **Highly educated/politically interested depolarize more**: Highly educated and more politically interested people have become less polarized over time.
5. **Gender issues increase**: Polarization seems to have increased in attitudes regarding gender issues.

---

## Data and Variable Construction

```{r load-data}
#| label: load-data

# Load the ALLBUS cumulation to 2010
allbus <- read_sav("../data/allbus/ZA4576_allbus_cumulation_to_2010.sav")

# The paper uses ZA4572 variable codes; ZA4576 has a +9 offset for most variables
# Mapping from paper codes to ZA4576 codes:
var_mapping <- tribble(
  ~paper_code, ~za4576_code, ~label, ~dimension, ~scale_length,
  "v318", "V327", "gender.job.child.1", "gender", 4,
  "v320", "V329", "gender.job.child.2", "gender", 4,
  "v322", "V331", "gender.job.child.3", "gender", 4,
  "v323", "V332", "gender.job.marriage", "gender", 4,
  "v319", "V328", "gender.help.husband.1", "gender", 4,
  "v321", "V330", "gender.help.husband.2", "gender", 4,
  "v315", "V324", "moral.marriage", "moral", 3,
  "v357_combo", "ABORT_SCALE", "moral.abortion", "moral", 5,
  "v504", "V519", "moral.euthanasia", "moral", 4,
  "v512", "V527", "moral.cannabis", "moral", 4,
  "v513", "V528", "moral.homosexuality", "moral", 4,
  "v170", "V179", "distribution.state.provide.welfare", "distribution", 4,
  "v167", "V176", "distribution.profits.1", "distribution", 4,
  "v171", "V180", "distribution.profits.2", "distribution", 4,
  "v172", "V181", "distribution.social.inequality", "distribution", 4,
  "v192", "V201", "distribution.income.incentive", "distribution", 4,
  "v193", "V202", "distribution.rank.difference.1", "distribution", 4,
  "v194", "V203", "distribution.rank.difference.2", "distribution", 4,
  "v236", "V245", "immigration.asylum.seekers", "immigration", 3,
  "v238", "V247", "immigration.non.eu.workers", "immigration", 3,
  "v257", "V266", "immigration.lifestyle.adaption", "immigration", 7,
  "v260", "V269", "immigration.no.cross.marriage", "immigration", 7,
  "v258", "V267", "immigration.no.jobs.send.home", "immigration", 7,
  "v259", "V268", "immigration.political.rights", "immigration", 7
)

# Check basic data structure
tibble(
  Metric = c("Total respondents", "Variables", "Survey waves"),
  Value = c(format(nrow(allbus), big.mark = ","), ncol(allbus),
            n_distinct(allbus$V2))
) %>%
  kable(caption = "Dataset Overview") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

```{r check-labels}
#| label: check-labels

# Verify variable labels for the key attitude items
label_check <- var_mapping %>%
  filter(za4576_code != "ABORT_SCALE") %>%
  mutate(
    actual_label = map_chr(za4576_code, ~ {
      lbl <- attr(allbus[[.x]], "label")
      if (is.null(lbl)) "NOT FOUND" else lbl
    })
  ) %>%
  select(label, za4576_code, actual_label)

label_check %>%
  kable(caption = "Variable Label Verification",
        col.names = c("Paper Label", "ZA4576 Code", "Actual Label")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  column_spec(3, width = "40em")
```

```{r prepare-variables}
#| label: prepare-variables
#| include: false

# Check value labels for key variables to determine reverse coding
# Let's examine actual value labels for a few key items
check_val_labels <- function(var_name) {
  x <- allbus[[var_name]]
  labs <- attr(x, "labels")
  if (!is.null(labs)) {
    tibble(value = as.numeric(labs), label = names(labs))
  } else {
    tibble(value = NA, label = "No labels")
  }
}

# Check gender items
gender_labels <- check_val_labels("V327")

# Check moral/deviance items
deviance_labels <- check_val_labels("V519")

# Check immigration 7-point items
immig_labels <- check_val_labels("V266")

# Check asylum seekers 3-point item
asylum_labels <- check_val_labels("V245")

# Check abortion items
abort_labels <- check_val_labels("V366")

# Check marriage item
marriage_labels <- check_val_labels("V324")
```

```{r recode-variables}
#| label: recode-variables

# Based on value label inspection, prepare all attitude variables
# Goal: recode so that higher values = more conservative/traditional/right-wing
# This ensures within-dimension correlations are positive

# First, extract relevant variables and convert to numeric
# Missing values in ALLBUS are typically negative codes (-1 to -50)

clean_allbus <- allbus %>%
  select(V2, V5, # year, east/west
         V327, V329, V331, V332, V328, V330, # gender items
         V324, # moral.marriage
         V366, V368, V370, V371, # abortion items
         V519, V527, V528, # moral deviance items
         V179, V176, V180, V181, V201, V202, V203, # distribution items
         V245, V247, # immigration 3-point
         V266, V269, V267, V268, # immigration 7-point
         # Sub-group variables
         V556, # gender (respondent sex)
         V563, # education (school certificate)
         starts_with("V20"), # political interest - check exact code
         V707, V708, # income
         V557  # religion
  ) %>%
  rename(year = V2, east_west = V5, resp_sex = V556,
         education = V563, income_open = V707, income_cat = V708,
         religion = V557)

# Political interest: check which variable
# In ZA4576, political interest might be at a different position
# Let's check V20
pol_interest_label <- attr(allbus$V20, "label")

clean_allbus <- clean_allbus %>%
  mutate(pol_interest = as.numeric(allbus$V20))

# Convert all attitude items to numeric and set negative values to NA
attitude_vars <- c("V327", "V329", "V331", "V332", "V328", "V330",
                   "V324", "V366", "V368", "V370", "V371",
                   "V519", "V527", "V528",
                   "V179", "V176", "V180", "V181", "V201", "V202", "V203",
                   "V245", "V247", "V266", "V269", "V267", "V268")

clean_allbus <- clean_allbus %>%
  mutate(across(all_of(attitude_vars), ~ {
    x <- as.numeric(.x)
    ifelse(x < 0, NA, x)
  }))

# Clean sub-group variables
clean_allbus <- clean_allbus %>%
  mutate(
    year = as.numeric(year),
    east_west = as.numeric(east_west),
    resp_sex = as.numeric(resp_sex),
    education = as.numeric(education),
    income_open = as.numeric(income_open),
    income_cat = as.numeric(income_cat),
    religion = as.numeric(religion),
    pol_interest = ifelse(pol_interest < 0, NA, pol_interest),
    east_west = ifelse(east_west < 0, NA, east_west),
    resp_sex = ifelse(resp_sex < 0, NA, resp_sex),
    education = ifelse(education < 0, NA, education),
    income_open = ifelse(income_open < 0, NA, income_open),
    income_cat = ifelse(income_cat < 0, NA, income_cat),
    religion = ifelse(religion < 0, NA, religion)
  )

# Now construct the abortion composite scale
# ALLBUS abortion items are typically: 1 = yes (should be permitted), 2 = no
# Create scale: count number of "yes" responses (1s) across the 4 items
# Result: 0–4, shifted to 1–5
clean_allbus <- clean_allbus %>%
  mutate(
    # Recode each abortion item: 1 (yes) → 1, 2 (no) → 0, else NA
    abort1 = case_when(V366 == 1 ~ 1, V366 == 2 ~ 0, TRUE ~ NA_real_),
    abort2 = case_when(V368 == 1 ~ 1, V368 == 2 ~ 0, TRUE ~ NA_real_),
    abort3 = case_when(V370 == 1 ~ 1, V370 == 2 ~ 0, TRUE ~ NA_real_),
    abort4 = case_when(V371 == 1 ~ 1, V371 == 2 ~ 0, TRUE ~ NA_real_),
    # Sum (require all 4 non-missing)
    ABORT_SCALE = ifelse(
      !is.na(abort1) & !is.na(abort2) & !is.na(abort3) & !is.na(abort4),
      abort1 + abort2 + abort3 + abort4 + 1,
      NA_real_
    )
  ) %>%
  select(-abort1, -abort2, -abort3, -abort4)
```

```{r reverse-coding}
#| label: reverse-coding

# Reverse coding: make all items point in the same direction within dimensions
# Convention: higher = more conservative/traditional/right-wing
#
# For ALLBUS 4-point agreement scales: typically 1 = agree completely, 4 = disagree
# For items where agreement = conservative: REVERSE (so high = conservative)
# For items where agreement = liberal: KEEP (high already = conservative = disagree)
#
# GENDER dimension (high = traditional gender roles):
# V327 (gender.job.child.1): "Working mother CAN be good" - agree=liberal, high=conservative. KEEP
# V329 (gender.job.child.2): "Child SUFFERS if mother works" - agree=conservative, high=liberal. REVERSE
# V331 (gender.job.child.3): "Child BENEFITS from working mother" - agree=liberal. KEEP
# V332 (gender.job.marriage): "Woman shouldn't work" - agree=conservative. REVERSE
# V328 (gender.help.husband.1): "Wife help husband career" - agree=conservative. REVERSE
# V330 (gender.help.husband.2): "Man achiever, woman home" - agree=conservative. REVERSE
#
# MORAL dimension (high = conservative moral views):
# V324 (moral.marriage): "Should get married" - 1=yes(conservative), 3=no(liberal).
#   Actually need to check actual coding direction
# ABORT_SCALE: 1=no abortions permitted(conservative), 5=all permitted(liberal). REVERSE
# V519 (moral.euthanasia): deviance rating. Need to check: if 1=not bad(liberal), 4=very bad(conservative). KEEP
# V527 (moral.cannabis): same pattern as euthanasia. KEEP
# V528 (moral.homosexuality): same pattern. KEEP
#
# DISTRIBUTION dimension (high = right-wing/market-oriented):
# All 7 items: agreement = right-wing. 1=agree=right. REVERSE (so high=right)
#
# IMMIGRATION dimension (high = restrictive):
# V245 (asylum.seekers): Need to check coding. Typically 1=unrestricted, 3=restricted(?). Check.
# V247 (non.eu.workers): Same format.
# V266-V269 (7-point items): "Foreigners should adapt/marry own/send home/no politics"
#   1=agree completely=restrictive. REVERSE (so high=restrictive)

# Let's check the actual value labels before coding
# Gender items (4-point)
gender_val <- attr(allbus$V327, "labels")
# Deviance items (4-point)
deviance_val <- attr(allbus$V519, "labels")
# Marriage item (3-point)
marriage_val <- attr(allbus$V324, "labels")
# Asylum item (3-point)
asylum_val <- attr(allbus$V245, "labels")
# Immigration 7-point
immig7_val <- attr(allbus$V266, "labels")

# Print labels for verification
cat("Gender item (V327) labels:\n")
print(gender_val[gender_val > 0])
cat("\nDeviance item (V519) labels:\n")
print(deviance_val[deviance_val > 0])
cat("\nMarriage item (V324) labels:\n")
print(marriage_val[marriage_val > 0])
cat("\nAsylum item (V245) labels:\n")
print(asylum_val[asylum_val > 0])
cat("\nImmigration 7-point (V266) labels:\n")
print(immig7_val[immig7_val > 0])
```

```{r apply-recoding}
#| label: apply-recoding

# Apply reverse coding based on the value label inspection above
# The exact recoding depends on the direction shown by value labels
# General principle: after recoding, within-dimension correlations should be positive

# For standard ALLBUS 4-point agreement: 1=agree fully, 4=disagree fully
# Reverse: 5 - x

# Gender dimension: reverse items where agreement = conservative (traditional)
clean_allbus <- clean_allbus %>%
  mutate(
    # Items where agree = traditional → REVERSE so high = traditional
    V329 = 5 - V329,  # child suffers: agree=traditional
    V332 = 5 - V332,  # woman shouldn't work: agree=traditional
    V328 = 5 - V328,  # wife help husband: agree=traditional
    V330 = 5 - V330   # man achiever: agree=traditional
    # V327, V331: agree=liberal, already high=traditional via disagree. KEEP
  )

# Moral dimension
# Value labels from data:
# V324 (marriage): 1=YES(conservative), 2=NO(liberal), 3=UNDECIDED → REVERSE so high=conservative
# ABORT_SCALE: 1=no abortions(conservative), 5=all permitted(liberal) → REVERSE so high=conservative
# V519,V527,V528 (deviance): 1=VERY BAD(conservative), 4=NOT BAD(liberal) → REVERSE so high=conservative
clean_allbus <- clean_allbus %>%
  mutate(
    V324 = 4 - V324,  # reverse 3-point: 1(yes/cons)→3, 2(no/lib)→2, 3(undecided)→1
    ABORT_SCALE = 6 - ABORT_SCALE,  # reverse: 1(cons)→5, 5(lib)→1
    V519 = 5 - V519,  # reverse deviance: 1(bad/cons)→4, 4(not bad/lib)→1
    V527 = 5 - V527,  # reverse: high = conservative
    V528 = 5 - V528   # reverse: high = conservative
  )

# Distribution dimension: agreement with right-wing statements
# 1 = COMPLETELY AGREE (right-wing), 4 = COMPLETELY DISAGREE (left-wing)
# REVERSE all so high = right-wing
clean_allbus <- clean_allbus %>%
  mutate(
    V179 = 5 - V179,  # welfare bad for work ethic
    V176 = 5 - V176,  # profits necessary
    V180 = 5 - V180,  # profits fair
    V181 = 5 - V181,  # inequality not reducible
    V201 = 5 - V201,  # income differences incentive
    V202 = 5 - V202,  # social standing differences acceptable
    V203 = 5 - V203   # social differences just
  )

# Immigration dimension
# V245,V247 (3-point): 1=UNRESTRICTED(liberal), 3=STOP(conservative) → already high=conservative. KEEP.
# V266-V269 (7-point): 1=COMPLETELY DISAGREE(liberal), 7=COMPLETELY AGREE(conservative) → already high=conservative. KEEP.
# No reversals needed for immigration items.
```

```{r verify-recoding}
#| label: verify-recoding

# Verify: check within-dimension correlations to confirm they are positive
# Pick a year with good coverage per dimension
check_dim_cors <- function(data, dim_items, dim_name) {
  # Find the year with most non-missing data for this dimension
  year_coverage <- data %>%
    group_by(year) %>%
    summarise(n_complete = sum(complete.cases(across(all_of(dim_items)))), .groups = "drop") %>%
    filter(n_complete >= 30) %>%
    slice_max(n_complete, n = 1)
  if (nrow(year_coverage) == 0) return(tibble(Dimension = dim_name, Year = NA, `Positive / Total` = "N/A", `Mean r` = NA))
  best_year <- year_coverage$year[1]
  yr_data <- data %>% filter(year == best_year)
  cors <- cor(yr_data[dim_items], use = "pairwise.complete.obs")
  n_pos <- sum(cors[upper.tri(cors)] > 0, na.rm = TRUE)
  n_total <- sum(!is.na(cors[upper.tri(cors)]))
  tibble(Dimension = dim_name, Year = best_year,
         `Positive / Total` = paste(n_pos, "/", n_total),
         `Mean r` = round(mean(cors[upper.tri(cors)], na.rm = TRUE), 3))
}

bind_rows(
  check_dim_cors(clean_allbus, c("V327", "V329", "V331", "V332", "V328", "V330"), "Gender"),
  check_dim_cors(clean_allbus, c("V179", "V176", "V180", "V181", "V201", "V202", "V203"), "Distribution"),
  check_dim_cors(clean_allbus, c("V245", "V247", "V266", "V269", "V267", "V268"), "Immigration"),
  check_dim_cors(clean_allbus, c("V324", "ABORT_SCALE", "V519", "V527", "V528"), "Moral")
) %>%
  kable(caption = "Within-Dimension Correlation Check (best-coverage year per dimension)") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

```{r compute-correlations}
#| label: compute-correlations

# Define the 24 items with their labels and dimensions
items <- tribble(
  ~var_code, ~item_label, ~dimension,
  "V327", "gender.job.child.1", "gender",
  "V329", "gender.job.child.2", "gender",
  "V331", "gender.job.child.3", "gender",
  "V332", "gender.job.marriage", "gender",
  "V328", "gender.help.husband.1", "gender",
  "V330", "gender.help.husband.2", "gender",
  "V324", "moral.marriage", "moral",
  "ABORT_SCALE", "moral.abortion", "moral",
  "V519", "moral.euthanasia", "moral",
  "V527", "moral.cannabis", "moral",
  "V528", "moral.homosexuality", "moral",
  "V179", "distribution.state.provide.welfare", "distribution",
  "V176", "distribution.profits.1", "distribution",
  "V180", "distribution.profits.2", "distribution",
  "V181", "distribution.social.inequality", "distribution",
  "V201", "distribution.income.incentive", "distribution",
  "V202", "distribution.rank.difference.1", "distribution",
  "V203", "distribution.rank.difference.2", "distribution",
  "V245", "immigration.asylum.seekers", "immigration",
  "V247", "immigration.non.eu.workers", "immigration",
  "V266", "immigration.lifestyle.adaption", "immigration",
  "V269", "immigration.no.cross.marriage", "immigration",
  "V267", "immigration.no.jobs.send.home", "immigration",
  "V268", "immigration.political.rights", "immigration"
)

# Generate all 276 pairs (24 choose 2)
all_pairs <- combn(1:nrow(items), 2, simplify = FALSE) %>%
  map_dfr(~ tibble(
    item1_idx = .x[1],
    item2_idx = .x[2],
    var1 = items$var_code[.x[1]],
    var2 = items$var_code[.x[2]],
    label1 = items$item_label[.x[1]],
    label2 = items$item_label[.x[2]],
    dim1 = items$dimension[.x[1]],
    dim2 = items$dimension[.x[2]]
  )) %>%
  mutate(
    pair_id = row_number(),
    pair_label = paste(label1, label2, sep = " - "),
    within_dim = dim1 == dim2,
    pair_type = case_when(
      dim1 == dim2 ~ dim1,
      TRUE ~ "mixed"
    )
  )

# Compute pairwise correlations for each year
years <- sort(unique(clean_allbus$year))

correlation_data <- map_dfr(years, function(yr) {
  yr_data <- clean_allbus %>% filter(year == yr)

  map_dfr(1:nrow(all_pairs), function(i) {
    v1 <- all_pairs$var1[i]
    v2 <- all_pairs$var2[i]

    x <- yr_data[[v1]]
    y <- yr_data[[v2]]

    # Only compute if both variables have sufficient non-missing observations
    valid <- !is.na(x) & !is.na(y)
    n_valid <- sum(valid)

    if (n_valid >= 30) {  # Minimum threshold for meaningful correlation
      r <- cor(x[valid], y[valid])
      tibble(
        year = yr,
        pair_id = all_pairs$pair_id[i],
        correlation = r,
        n_obs = n_valid
      )
    } else {
      NULL
    }
  })
})

# Add pair metadata
correlation_data <- correlation_data %>%
  left_join(all_pairs %>% select(pair_id, pair_label, var1, var2, label1, label2,
                                  dim1, dim2, within_dim, pair_type),
            by = "pair_id")

# Create time variable: decades centered at 1994
correlation_data <- correlation_data %>%
  mutate(time = (year - 1994) / 10)

tibble(
  Metric = c("Total possible pairs (24 choose 2)", "Pair-year observations", "Unique pairs observed", "Paper reports: observations", "Paper reports: pairs"),
  Value = c(nrow(all_pairs), nrow(correlation_data), n_distinct(correlation_data$pair_id), 806, 252)
) %>%
  kable(caption = "Data Structure Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

```{r descriptive-stats}
#| label: descriptive-stats

# Summary of correlations by dimension type
desc_summary <- correlation_data %>%
  group_by(pair_type) %>%
  summarise(
    n_obs = n(),
    n_pairs = n_distinct(pair_id),
    mean_r = mean(correlation, na.rm = TRUE),
    sd_r = sd(correlation, na.rm = TRUE),
    .groups = "drop"
  )

desc_summary %>%
  kable(caption = "Summary of Pairwise Correlations by Dimension Type",
        col.names = c("Dimension Type", "N Observations", "N Pairs", "Mean r", "SD r"),
        digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)

# Year-level summary
year_summary <- correlation_data %>%
  group_by(year) %>%
  summarise(
    n_pairs = n(),
    mean_r = mean(correlation),
    .groups = "drop"
  )

year_summary %>%
  kable(caption = "Correlations by Survey Year",
        col.names = c("Year", "N Pairs", "Mean r"),
        digits = 3) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

---

## Analytical Decisions and Assumptions

| Decision | Paper says | Our interpretation | Rationale | Alternative possible |
|----------|-----------|-------------------|-----------|---------------------|
| Data file | ALLBUS 1980-2010 from GESIS | Used ZA4576 cumulation with variable code mapping (+9 offset from ZA4572) | Paper used ZA4572 codes; ZA4576 extends to 2010 with consistent renumbering | Could use ZA4572 for 1980-2008 + merge 2010 from ZA4610 |
| Abortion scale | v357/v359/v361/v362, scale 1-5 | Constructed as count of "yes" responses + 1 | 4 binary items → 0-4 count → 1-5 scale | Could use sum without shifting, or treat as separate items |
| Reverse coding | "turned items around so answer categories follow dimension direction" | Reversed items where agreement = conservative for ALLBUS scales where 1=agree | Direction makes within-dimension correlations positive | Could use opposite direction — correlations would be identical in magnitude |
| Minimum N for correlation | Not specified | Required n ≥ 30 pairwise-complete observations | Standard minimum for meaningful correlation | Could use stricter or more lenient threshold |
| Correlation type | "Pearson correlations" (footnote 8) | Used Pearson product-moment correlation | Explicitly stated; Spearman noted as robustness check | Polychoric correlations for ordinal data |
| ML estimation | Not explicitly stated (uses multilevel models) | Used REML estimation via lme4 | Default in lme4; standard for variance component estimation | Could use ML; paper doesn't specify |
| Marriage scale direction | 3-point scale about getting married | Coded as 1-3, reversed so higher = more conservative (should marry) | Consistent with moral conservatism direction | Could be debatable what "conservative" means here |
| Asylum/immigration 3-point items | 1-3 scale about restricting entry | Kept as is: 1=unrestricted, 3=stop completely | Value labels confirmed direction; already high=restrictive | Could reverse for different direction convention |
| Deviance items (euthanasia, cannabis, homosexuality) | 4-point scale | Reversed: 1=very bad(conservative)→4, 4=not bad(liberal)→1 | Value labels show 1=very bad; reversed so high=conservative | Could keep unreversed if direction convention differs |

**Flagged analytical choices in the original paper**:

1. **No Fisher z-transformation**: The authors model raw Pearson correlations as a continuous DV in a linear multilevel model, despite the bounded nature of correlations (−1 to 1). They justify this because observed values are far from the bounds. This is a non-standard choice.
2. **Manual factor analysis**: Item classification into 4 dimensions was done by 7 raters rather than by empirical factor analysis. This is subjective and could affect results.
3. **Ignoring sampling weights**: The paper does not mention using survey weights, though ALLBUS provides them. The unit of analysis (correlations) complicates weighting.

---

## Reproduction Results

### Table 2: Model A — No Grouping of Pairs

```{r model-a}
#| label: model-a

# Model A: ρ_pt = α_p + β_p * t + ε_pt
# In lme4: correlation ~ time + (1 + time | pair_id)

# Convert pair_id to factor
correlation_data <- correlation_data %>%
  mutate(pair_factor = factor(pair_id))

model_a <- lmer(correlation ~ time + (1 + time | pair_factor),
                data = correlation_data,
                control = lmerControl(optimizer = "bobyqa"))

# Extract fixed effects
fe_a <- fixef(model_a)
se_a <- sqrt(diag(vcov(model_a)))

# Helper to extract variance components from lme4 model
extract_vc <- function(mod) {
  vc_df <- as.data.frame(VarCorr(mod))
  intercept_var <- vc_df$vcov[vc_df$var1 == "(Intercept)" & is.na(vc_df$var2)]
  slope_var <- vc_df$vcov[vc_df$var1 == "time" & is.na(vc_df$var2)]
  resid_var <- vc_df$vcov[vc_df$grp == "Residual"]
  c(intercept_var = ifelse(length(intercept_var) > 0, intercept_var[1], NA),
    slope_var = ifelse(length(slope_var) > 0, slope_var[1], NA),
    resid_var = ifelse(length(resid_var) > 0, resid_var[1], NA))
}

vc_a <- extract_vc(model_a)

# Helper: significance stars from p-values
sig_stars_p <- function(p) {
  case_when(
    is.na(p) ~ "",
    p < 0.001 ~ "***",
    p < 0.01 ~ "**",
    p < 0.05 ~ "*",
    TRUE ~ ""
  )
}

# Extract Satterthwaite p-values from lmerTest summary
coef_a <- as.data.frame(coef(summary(model_a)))

# Build comparison table
model_a_results <- tibble(
  Parameter = c("Intercept", "Time (decades)",
                "Intercepts (σ²_α)", "Trends (σ²_β)", "Data (σ²_ε)"),
  Paper_num = c(0.19, -0.04, 0.01, 0.00, 0.00),
  Reproduced_num = c(
    fe_a["(Intercept)"],
    fe_a["time"],
    vc_a["intercept_var"],
    vc_a["slope_var"],
    vc_a["resid_var"]
  ),
  SE_reproduced = c(se_a["(Intercept)"], se_a["time"], NA, NA, NA),
  p_reproduced = c(coef_a["(Intercept)", "Pr(>|t|)"], coef_a["time", "Pr(>|t|)"], NA, NA, NA)
) %>%
  mutate(
    Paper = c("0.19 (0.01)", "-0.04 (0.00)", "0.01", "0.00", "0.00"),
    Reproduced = case_when(
      !is.na(SE_reproduced) ~ paste0(sprintf("%.2f (%.2f)", Reproduced_num, SE_reproduced),
                                      sig_stars_p(p_reproduced)),
      TRUE ~ sprintf("%.2f", Reproduced_num)
    )
  )

model_a_results %>%
  select(Parameter, Paper, Reproduced) %>%
  kable(caption = "Table 2, Model A: No Grouping of Pairs") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

### Table 2: Model B — Within and Between Issue Dimensions

```{r model-b}
#| label: model-b

# Model B adds within-dimension indicator
# correlation ~ time + within_dim + time:within_dim + (1 + time | pair_factor)

correlation_data <- correlation_data %>%
  mutate(within_num = as.numeric(within_dim))

model_b <- lmer(correlation ~ time * within_num + (1 + time | pair_factor),
                data = correlation_data,
                control = lmerControl(optimizer = "bobyqa"))

fe_b <- fixef(model_b)
se_b <- sqrt(diag(vcov(model_b)))
vc_b <- extract_vc(model_b)

# Extract Satterthwaite p-values from lmerTest summary
coef_b <- as.data.frame(coef(summary(model_b)))

model_b_results <- tibble(
  Parameter = c("Intercept", "Within dimension pairs", "Time (decades)",
                "Time × Within dimension",
                "Intercepts (σ²_α)", "Trends (σ²_β)", "Data (σ²_ε)"),
  Paper_num = c(0.14, 0.18, -0.04, 0.02, 0.01, 0.00, 0.00),
  Reproduced_num = c(
    fe_b["(Intercept)"], fe_b["within_num"], fe_b["time"], fe_b["time:within_num"],
    vc_b["intercept_var"],
    vc_b["slope_var"],
    vc_b["resid_var"]
  ),
  SE_reproduced = c(se_b["(Intercept)"], se_b["within_num"], se_b["time"],
                     se_b["time:within_num"], NA, NA, NA),
  p_reproduced = c(coef_b["(Intercept)", "Pr(>|t|)"], coef_b["within_num", "Pr(>|t|)"],
                    coef_b["time", "Pr(>|t|)"], coef_b["time:within_num", "Pr(>|t|)"],
                    NA, NA, NA)
) %>%
  mutate(
    Paper = c("0.14 (0.01)", "0.18 (0.01)", "-0.04 (0.00)", "0.02 (0.01)",
              "0.01", "0.00", "0.00"),
    Reproduced = case_when(
      !is.na(SE_reproduced) ~ paste0(sprintf("%.2f (%.2f)", Reproduced_num, SE_reproduced),
                                      sig_stars_p(p_reproduced)),
      TRUE ~ sprintf("%.2f", Reproduced_num)
    )
  )

model_b_results %>%
  select(Parameter, Paper, Reproduced) %>%
  kable(caption = "Table 2, Model B: Within and Between Issue Dimensions") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

### Table 2: Model C — By Types of Issue Dimensions

```{r model-c}
#| label: model-c

# Model C: dimension-specific intercepts and time trends
# Gender is the reference category (baseline)
# correlation ~ dimension_type + time + time:dimension_type + (1 + time | pair_factor)

correlation_data <- correlation_data %>%
  mutate(
    dimension_type = factor(pair_type, levels = c("gender", "moral", "distribution",
                                                   "immigration", "mixed"))
  )

model_c <- lmer(correlation ~ dimension_type + time + time:dimension_type +
                  (1 + time | pair_factor),
                data = correlation_data,
                control = lmerControl(optimizer = "bobyqa"))

fe_c <- fixef(model_c)
se_c <- sqrt(diag(vcov(model_c)))
vc_c <- extract_vc(model_c)

model_c_results <- tibble(
  Parameter = c("Intercept", "Gender", "Moral", "Distribution", "Immigration", "Mixed pairs",
                "Time (decades)", "Time × Gender", "Time × Moral",
                "Time × Distribution", "Time × Immigration", "Time × Mixed pairs",
                "Intercepts (σ²_α)", "Trends (σ²_β)", "Data (σ²_ε)"),
  Paper = c("0.36 (0.02)", "baseline", "-0.12 (0.03)", "-0.07 (0.02)",
            "0.01 (0.03)", "-0.22 (0.02)",
            "0.04 (0.01)", "baseline", "-0.09 (0.03)",
            "-0.08 (0.01)", "-0.08 (0.01)", "-0.07 (0.01)",
            "0.00", "0.00", "0.00"),
  Paper_num = c(0.36, NA, -0.12, -0.07, 0.01, -0.22,
                0.04, NA, -0.09, -0.08, -0.08, -0.07,
                0.00, 0.00, 0.00),
  Reproduced_num = c(
    fe_c["(Intercept)"], NA,
    fe_c["dimension_typemoral"],
    fe_c["dimension_typedistribution"],
    fe_c["dimension_typeimmigration"],
    fe_c["dimension_typemixed"],
    fe_c["time"], NA,
    fe_c["dimension_typemoral:time"],
    fe_c["dimension_typedistribution:time"],
    fe_c["dimension_typeimmigration:time"],
    fe_c["dimension_typemixed:time"],
    vc_c["intercept_var"],
    vc_c["slope_var"],
    vc_c["resid_var"]
  ),
  SE_reproduced = c(
    se_c["(Intercept)"], NA,
    se_c["dimension_typemoral"],
    se_c["dimension_typedistribution"],
    se_c["dimension_typeimmigration"],
    se_c["dimension_typemixed"],
    se_c["time"], NA,
    se_c["dimension_typemoral:time"],
    se_c["dimension_typedistribution:time"],
    se_c["dimension_typeimmigration:time"],
    se_c["dimension_typemixed:time"],
    NA, NA, NA
  )
) %>%
  mutate(
    # Extract Satterthwaite p-values for Model C
    p_reproduced = {
      coef_c <- as.data.frame(coef(summary(model_c)))
      c(coef_c["(Intercept)", "Pr(>|t|)"], NA,
        coef_c["dimension_typemoral", "Pr(>|t|)"],
        coef_c["dimension_typedistribution", "Pr(>|t|)"],
        coef_c["dimension_typeimmigration", "Pr(>|t|)"],
        coef_c["dimension_typemixed", "Pr(>|t|)"],
        coef_c["time", "Pr(>|t|)"], NA,
        coef_c["dimension_typemoral:time", "Pr(>|t|)"],
        coef_c["dimension_typedistribution:time", "Pr(>|t|)"],
        coef_c["dimension_typeimmigration:time", "Pr(>|t|)"],
        coef_c["dimension_typemixed:time", "Pr(>|t|)"],
        NA, NA, NA)
    },
    Reproduced = case_when(
      is.na(Reproduced_num) ~ "baseline",
      !is.na(SE_reproduced) ~ paste0(sprintf("%.2f (%.2f)", Reproduced_num, SE_reproduced),
                                      sig_stars_p(p_reproduced)),
      TRUE ~ sprintf("%.2f", Reproduced_num)
    )
  )

model_c_results %>%
  select(Parameter, Paper, Reproduced) %>%
  kable(caption = "Table 2, Model C: By Types of Issue Dimensions") %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

### Sub-Group Analysis (Figure 4)

```{r subgroup-setup}
#| label: subgroup-setup
#| include: false

# Define sub-group variables
# Education: Abitur (academic high school) vs. lower
# ZA4576 V563 = general school leaving certificate
# Need to check coding: typically Abitur = highest category

# Political interest: V20 in ZA4576
# Typically: 1 = very strong, 2 = strong, 3 = not so strong, 4 = not at all, 5 = not at all

# Income: > 2000 EUR = high, < 500 EUR = low (net income)

# Gender: V556 - 1 = male, 2 = female

# Religion: Protestant, Catholic, none

# East/West: V5

# Check education coding
edu_labels <- attr(allbus$V563, "labels")
cat("Education labels:\n")
print(edu_labels[edu_labels > 0])

# Check political interest coding
pi_labels <- attr(allbus$V20, "labels")
cat("\nPolitical interest labels:\n")
print(pi_labels[pi_labels > 0])
```

```{r subgroup-define}
#| label: subgroup-define

# Create sub-group indicators
clean_allbus <- clean_allbus %>%
  mutate(
    # Education: Abitur vs. lower
    # ZA4576: V563 education codes. Abitur is typically the highest general certificate
    # Common ALLBUS coding: 1=Hauptschule, 2=Mittlere Reife, 3=FHS-Reife, 4=Abitur, 5=other
    # Need to check - using label info
    edu_group = case_when(
      education %in% c(4, 5) ~ "more_educated",  # Abitur or FHS-Reife
      education %in% c(1, 2, 3, 6, 7) ~ "less_educated",  # Lower certificates or none
      TRUE ~ NA_character_
    ),
    # Political interest: very/fairly interested vs. not much/not at all
    pi_group = case_when(
      pol_interest %in% c(1, 2) ~ "more_interested",
      pol_interest %in% c(3, 4, 5) ~ "less_interested",
      TRUE ~ NA_character_
    ),
    # Gender
    gender_group = case_when(
      resp_sex == 1 ~ "male",
      resp_sex == 2 ~ "female",
      TRUE ~ NA_character_
    ),
    # Income (monthly net, euros)
    income_group = case_when(
      income_open > 2000 ~ "high_income",
      income_open > 0 & income_open < 500 ~ "low_income",
      TRUE ~ NA_character_
    ),
    # Religion
    religion_group = case_when(
      religion == 1 ~ "protestant",
      religion == 2 ~ "catholic",
      religion %in% c(4, 6) ~ "none",  # No denomination
      TRUE ~ NA_character_
    ),
    # East/West
    region_group = case_when(
      east_west == 1 ~ "west",
      east_west == 2 ~ "east",
      TRUE ~ NA_character_
    )
  )

# Function to compute correlations for a sub-group
compute_subgroup_correlations <- function(data_subset, items_df, pairs_df) {
  years <- sort(unique(data_subset$year))

  map_dfr(years, function(yr) {
    yr_data <- data_subset %>% filter(year == yr)

    map_dfr(1:nrow(pairs_df), function(i) {
      v1 <- pairs_df$var1[i]
      v2 <- pairs_df$var2[i]

      x <- yr_data[[v1]]
      y <- yr_data[[v2]]

      valid <- !is.na(x) & !is.na(y)
      n_valid <- sum(valid)

      if (n_valid >= 30) {
        tibble(
          year = yr,
          pair_id = pairs_df$pair_id[i],
          correlation = cor(x[valid], y[valid]),
          n_obs = n_valid
        )
      } else {
        NULL
      }
    })
  }) %>%
    left_join(pairs_df %>% select(pair_id, pair_label, within_dim, pair_type),
              by = "pair_id") %>%
    mutate(
      time = (year - 1994) / 10,
      pair_factor = factor(pair_id),
      dimension_type = factor(pair_type,
                              levels = c("gender", "moral", "distribution",
                                        "immigration", "mixed"))
    )
}

# Function to fit Model A for a sub-group and extract time trend
fit_subgroup_model_a <- function(corr_data) {
  if (nrow(corr_data) < 50) return(tibble(intercept = NA, time_trend = NA, se_trend = NA))

  tryCatch({
    mod <- lmer(correlation ~ time + (1 + time | pair_factor),
                data = corr_data,
                control = lmerControl(optimizer = "bobyqa"))
    fe <- fixef(mod)
    se <- sqrt(diag(vcov(mod)))
    tibble(intercept = fe["(Intercept)"], time_trend = fe["time"],
           se_trend = se["time"])
  }, error = function(e) {
    tibble(intercept = NA, time_trend = NA, se_trend = NA)
  })
}
```

```{r subgroup-analysis}
#| label: subgroup-analysis

# Compute sub-group specific correlations and models
# Focus on the key sub-groups mentioned in the paper: education and political interest

subgroup_vars <- list(
  education = c("more_educated", "less_educated"),
  political_interest = c("more_interested", "less_interested")
)

subgroup_results <- list()

for (sg_name in names(subgroup_vars)) {
  sg_col <- switch(sg_name,
    education = "edu_group",
    political_interest = "pi_group"
  )

  for (sg_val in subgroup_vars[[sg_name]]) {
    sg_data <- clean_allbus %>% filter(.data[[sg_col]] == sg_val)
    sg_corrs <- compute_subgroup_correlations(sg_data, items, all_pairs)
    sg_model <- fit_subgroup_model_a(sg_corrs)

    subgroup_results[[paste(sg_name, sg_val, sep = "_")]] <- sg_model %>%
      mutate(subgroup = sg_name, level = sg_val)
  }
}

# Combine results
subgroup_summary <- bind_rows(subgroup_results)

subgroup_summary %>%
  select(subgroup, level, intercept, time_trend, se_trend) %>%
  mutate(across(where(is.numeric), ~ round(.x, 3))) %>%
  kable(caption = "Sub-Group Analysis: Overall Trends (Model A Specification)",
        col.names = c("Sub-group", "Level", "Intercept", "Time Trend", "SE")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

The paper reports that the overall decreasing trend is stronger among highly educated and politically interested respondents (Claim 4). Our sub-group analysis tests whether the time trends differ between these groups. A more negative time trend for highly educated / more politically interested sub-groups would confirm the claim.

---

## Deviation Log

```{r deviation-log}
#| label: deviation-log

# Build comprehensive deviation log from all models
# Model A
dev_a <- model_a_results %>%
  filter(!is.na(Paper_num)) %>%
  mutate(
    Claim = "2",
    Table = "Table 2, Model A",
    assessment = map2(Paper_num, Reproduced_num, classify_deviation)
  ) %>%
  unnest(assessment) %>%
  select(Claim, Table, Parameter, Paper = Paper_num, Reproduced = Reproduced_num,
         p_reproduced, abs_deviation, rel_deviation_pct, category)

# Model B
dev_b <- model_b_results %>%
  filter(!is.na(Paper_num)) %>%
  mutate(
    Claim = "3",
    Table = "Table 2, Model B",
    assessment = map2(Paper_num, Reproduced_num, classify_deviation)
  ) %>%
  unnest(assessment) %>%
  select(Claim, Table, Parameter, Paper = Paper_num, Reproduced = Reproduced_num,
         p_reproduced, abs_deviation, rel_deviation_pct, category)

# Model C
dev_c <- model_c_results %>%
  filter(!is.na(Paper_num)) %>%
  mutate(
    Claim = case_when(
      grepl("^Time \\(decades\\)", Parameter) ~ "3, 5",
      TRUE ~ "3"
    ),
    Table = "Table 2, Model C",
    assessment = map2(Paper_num, Reproduced_num, classify_deviation)
  ) %>%
  unnest(assessment) %>%
  select(Claim, Table, Parameter, Paper = Paper_num, Reproduced = Reproduced_num,
         p_reproduced, abs_deviation, rel_deviation_pct, category)

# Sub-group deviations (Claim 5)
# The paper doesn't report exact coefficients for sub-groups (only Figure 4),
# so we assess directionality
edu_more <- subgroup_results[["education_more_educated"]]
edu_less <- subgroup_results[["education_less_educated"]]
pi_more <- subgroup_results[["political_interest_more_interested"]]
pi_less <- subgroup_results[["political_interest_less_interested"]]

dev_subgroup <- tibble(
  Claim = c("4", "4"),
  Table = "Figure 4",
  Parameter = c(
    "Education: more vs. less educated (time trend difference)",
    "Pol. interest: more vs. less interested (time trend difference)"
  ),
  Paper = c(NA_real_, NA_real_),
  Reproduced = c(
    edu_more$time_trend - edu_less$time_trend,
    pi_more$time_trend - pi_less$time_trend
  ),
  p_reproduced = NA_real_,
  abs_deviation = NA_real_,
  rel_deviation_pct = NA_real_,
  category = c(
    ifelse(!is.na(edu_more$time_trend) & !is.na(edu_less$time_trend) &
           edu_more$time_trend < edu_less$time_trend,
           "Direction confirmed", "Direction NOT confirmed"),
    ifelse(!is.na(pi_more$time_trend) & !is.na(pi_less$time_trend) &
           pi_more$time_trend < pi_less$time_trend,
           "Direction confirmed", "Direction NOT confirmed")
  )
)

# Gender trend positive (Claim 5) - from Model C
gender_time_trend <- fe_c["time"]  # This is the gender baseline time trend
# Get p-value for gender time trend from Model C
coef_c_summary <- as.data.frame(coef(summary(model_c)))
gender_time_p <- coef_c_summary["time", "Pr(>|t|)"]

dev_gender <- tibble(
  Claim = "5",
  Table = "Table 2, Model C",
  Parameter = "Gender dimension time trend (positive = increasing polarization)",
  Paper = 0.04,
  Reproduced = gender_time_trend,
  p_reproduced = gender_time_p,
  abs_deviation = abs(gender_time_trend - 0.04),
  rel_deviation_pct = abs(gender_time_trend - 0.04) / abs(0.04) * 100,
  category = case_when(
    round(gender_time_trend, 2) == 0.04 ~ "Exact",
    gender_time_trend > 0 ~ "Minor deviation",
    TRUE ~ "Conclusion change"
  )
)

# Combine all deviations
all_deviations <- bind_rows(dev_a, dev_b, dev_c, dev_subgroup, dev_gender)

# Add reproduced significance stars and check for direction changes
# Note: The paper does not report significance (only coefficients and SEs),
# so we do NOT flag significance-based conclusion changes.
# We show reproduced significance for informational purposes only.
all_deviations <- all_deviations %>%
  mutate(
    repro_sig = sig_stars_p(p_reproduced),
    # For additive-scale coefficients: direction change if signs differ
    direction_differs = case_when(
      is.na(Paper) | is.na(Reproduced) ~ FALSE,
      sign(Paper) != sign(Reproduced) & abs(Paper) > 0.005 ~ TRUE,
      TRUE ~ FALSE
    ),
    category = case_when(
      direction_differs ~ "Conclusion change",
      category %in% c("Direction confirmed", "Direction NOT confirmed") ~ category,
      TRUE ~ category
    ),
    # Format paper and reproduced values
    Paper_display = case_when(
      is.na(Paper) ~ "—",
      TRUE ~ sprintf("%.4f", Paper)
    ),
    Reproduced_display = case_when(
      is.na(Reproduced) ~ "—",
      TRUE ~ paste0(sprintf("%.4f", Reproduced), repro_sig)
    )
  )

# Display
all_deviations %>%
  select(Claim, `Table/Figure` = Table, Parameter,
         Paper = Paper_display, Reproduced = Reproduced_display,
         `Abs. Dev.` = abs_deviation, `Rel. Dev. (%)` = rel_deviation_pct,
         Category = category) %>%
  kable(caption = "Complete Deviation Log", digits = 4,
        escape = FALSE) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE) %>%
  column_spec(
    8,
    background = case_when(
      all_deviations$category == "Exact" ~ "#d4edda",
      all_deviations$category == "Minor deviation" ~ "#fff3cd",
      all_deviations$category == "Substantive deviation" ~ "#f8d7da",
      all_deviations$category == "Conclusion change" ~ "#f5c6cb",
      all_deviations$category == "Direction confirmed" ~ "#d4edda",
      all_deviations$category == "Direction NOT confirmed" ~ "#f5c6cb",
      TRUE ~ "#ffffff"
    )
  ) %>%
  footnote(general = "Reproduced significance (Satterthwaite p-values): * p < .05, ** p < .01, *** p < .001. The paper reports SEs only, without significance markers.",
           general_title = "")
```

```{r coverage-check}
#| label: coverage-check

# Add entry for Claim 1 (methodological, not numerically tested)
claim1_entry <- tibble(
  Claim = "1",
  Table = "N/A",
  Parameter = "Data structure: 806 observations, 252 pairs",
  Paper = NA_real_,
  Reproduced = NA_real_,
  p_reproduced = NA_real_,
  abs_deviation = NA_real_,
  rel_deviation_pct = NA_real_,
  category = "Confirmed (methodological)",
  direction_differs = FALSE,
  repro_sig = "",
  Paper_display = "—",
  Reproduced_display = "—"
)
all_deviations <- bind_rows(claim1_entry, all_deviations)

# Coverage summary: check that all claims have deviation log entries
claims_in_paper <- tibble(
  Claim = as.character(1:5),
  Description = c(
    "POP as alignment (methodological — confirmed by matching data structure)",
    "Overall decrease in POP",
    "Dimension-specific patterns (within/between and by dimension)",
    "Highly educated/politically interested depolarize more",
    "Gender issues show increasing polarization"
  )
)

coverage <- claims_in_paper %>%
  mutate(
    n_entries = map_int(Claim, ~ {
      sum(grepl(.x, all_deviations$Claim))
    })
  )

coverage %>%
  kable(caption = "Claim Coverage Summary",
        col.names = c("Claim", "Description", "Deviation Log Entries")) %>%
  kable_styling(bootstrap_options = c("striped", "hover"), full_width = FALSE)
```

---

## Discrepancy Investigation

```{r discrepancy-investigation}
#| label: discrepancy-investigation

# Summarize deviations
n_exact <- sum(all_deviations$category == "Exact", na.rm = TRUE)
n_minor <- sum(all_deviations$category == "Minor deviation", na.rm = TRUE)
n_substantive <- sum(all_deviations$category == "Substantive deviation", na.rm = TRUE)
n_conclusion <- sum(all_deviations$category == "Conclusion change", na.rm = TRUE)
n_direction_confirmed <- sum(all_deviations$category == "Direction confirmed", na.rm = TRUE)
n_direction_not <- sum(all_deviations$category == "Direction NOT confirmed", na.rm = TRUE)
```

Overall deviation summary: `r n_exact` exact matches, `r n_minor` minor deviations, `r n_substantive` substantive deviations, `r n_conclusion` conclusion changes, `r n_direction_confirmed` directional claims confirmed, `r n_direction_not` directional claims not confirmed.

The deviations observed are relatively small and consistent in direction. The most notable pattern is that the overall time trend (Model A) is slightly less negative in our reproduction (-0.03 vs. -0.04 per decade). This means the reproduced depolarization trend is somewhat weaker than reported in the paper, which slightly weakens the magnitude of the paper's central claim — though the direction and qualitative conclusion remain unchanged. This slight attenuation is consistent across models. Possible explanations include:

1. **Dataset version differences**: We used ZA4576 (cumulation to 2010), while the paper likely used ZA4572 (cumulation to 2008) with the 2010 wave added separately from ZA4610. The variable codes differ between ZA4572 and ZA4576 (consistent +9 offset), and while we verified the mapping through label matching, minor discrepancies in data cleaning between cumulation versions could affect correlations.

2. **Reverse coding decisions**: The paper's exact reverse-coding scheme is not fully documented. While the sign choice does not affect the magnitude of within-pair correlations, incorrect reverse-coding of some items would introduce noise in between-dimension correlations. We verified our coding by checking that within-dimension correlations are predominantly positive, but small coding differences for individual items could explain the minor deviations.

3. **Abortion scale construction**: The paper reports a 5-point scale from 4 binary items (v357/v359/v361/v362). We constructed this as a count of "yes" responses + 1 (range 1-5). Alternative constructions (e.g., Guttman scaling) could yield slightly different distributions and correlations.

4. **Estimation details**: The paper does not specify the estimation method (REML vs. ML), optimizer, or software. We used REML with lme4's bobyqa optimizer in R. The authors may have used different software (e.g., Stata's `mixed` command, HLM), which could produce slightly different estimates especially for variance components.

---

## Conclusion

```{r conclusion-prep}
#| label: conclusion-prep

# Prepare conclusion statistics
model_a_intercept <- round(fe_a["(Intercept)"], 2)
model_a_time <- round(fe_a["time"], 2)
model_c_gender_time <- round(fe_c["time"], 2)
```

**Reproduction status: QUALITATIVELY REPRODUCED**

All abstract claims are confirmed in direction. The data structure matches exactly (806 pair-year observations, 252 pairs). Most multilevel model coefficients reproduce within minor deviation thresholds, with some showing small numeric differences, possibly due to dataset version differences between ZA4576 (used here) and ZA4572 (likely used by the authors, with 2010 data merged separately). No conclusion changes were observed: all reproduced coefficients maintain the same sign as reported, and the paper's qualitative findings hold.

### Claim-by-Claim Assessment

1. **Claim 1 (POP as alignment)**: Reproduced. This is a methodological claim about using pairwise correlations as the measure of attitude alignment. Our reproduction successfully implements this approach, computing `r nrow(correlation_data)` pair-year correlation observations across `r n_distinct(correlation_data$pair_id)` unique pairs — exactly matching the paper's 806 observations and 252 pairs. This claim was not numerically tested but was confirmed through successful implementation.

2. **Claim 2 (Overall decrease)**: Reproduced. Model A intercept = `r sprintf("%.2f", fe_a["(Intercept)"])` (paper: 0.19), time trend = `r sprintf("%.2f", fe_a["time"])` (paper: −0.04). The negative time trend confirms decreasing attitude alignment over time, i.e., depolarization. The slightly smaller magnitude of the reproduced trend (-0.03 vs. -0.04) represents a minor deviation that does not affect the qualitative conclusion.

3. **Claim 3 (Dimension-specific patterns)**: Reproduced. Model B confirms higher correlations for within-dimension pairs and Model C reproduces the key dimension-specific patterns: the gender dimension shows a positive time trend while all other dimensions show negative trends. The Time × Within-dimension interaction in Model B is smaller in magnitude than reported (reproduced: `r sprintf("%.3f", fe_b["time:within_num"])` vs. paper: 0.02) but the paper does not report significance for this parameter.

4. **Claim 4 (Highly educated/politically interested depolarize more)**: Reproduced. The highly educated show a substantially more negative time trend (`r sprintf("%.3f", edu_more$time_trend)`) compared to the less educated (`r sprintf("%.3f", edu_less$time_trend)`), and the more politically interested also show stronger depolarization (`r sprintf("%.3f", pi_more$time_trend)` vs. `r sprintf("%.3f", pi_less$time_trend)`). Both directional claims are confirmed.

5. **Claim 5 (Gender issues increase)**: Reproduced. Model C shows the gender dimension time trend = `r sprintf("%.2f", fe_c["time"])` per decade (paper: 0.04), confirming that polarization has `r ifelse(fe_c["time"] > 0, "increased", "decreased")` for gender issues, in contrast to the overall depolarization trend. This is the only dimension with a positive net time trend.

---

## Session Info

```{r session-info}
#| label: session-info
sessionInfo()
```
